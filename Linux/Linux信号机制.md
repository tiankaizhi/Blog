## 摘要

本文首先介绍了信号的本质及信号的来源，然后从不同角度阐述了信号的种类，接着对信号的生命周期做了详细的介绍。通过对这些内容的学习，可以加深对信号的理解。

## 信号本质

信号是在软件层次上对 OS 中断机制的一种模拟。在原理上，一个进程收到一个信号与处理器收到一个中断请求是类似的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。

## 信号来源

信号事件的发生有两个来源：硬件来源（如键盘或硬件故障）；软件来源，最常用发送信号的系统函数是 ```kill```，```raise```，```alarm```，```setitimer```，```sigqueue``` 等函数，软件来源还包括一些非法运算等操作。

## 信号种类

信号的分类大概可以从可靠性方面和实时性方面分为两类，即可靠，不可靠信号；实时，非实时信号。

### 可靠性方面

#### 不可靠信号

Linux 信号机制基本上是从 Unix 系统中继承过来的。早期 Unix 系统中的信号机制比较简单和原始，后来在实践中暴露出一些问题，因此，把那些建立在早期机制上的信号叫做"不可靠信号"，信号值小于 ```SIGRTMIN``` 的信号都是不可靠信号。这就是"不可靠信号"的来源。不可靠信号主要存在两个问题：

1. 进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理；因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用 ```signal()```，重新安装该信号。

2. 信号可能丢失。

Linux 支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数（信号安装函数是在可靠机制上的实现）。因此，**Linux 下的不可靠信号问题主要指的是信号可能丢失**。

#### 可靠信号

随着时间的发展，后来出现的各种 Unix 版本力图实现"可靠信号"。由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，**可靠信号的信号值值位于 ```SIGRTMIN``` 和 ```SIGRTMAX``` 之间，这些信号支持排队，不会丢失**。

同时，信号的发送和安装也出现了新版本：信号发送函数 ```sigqueue()``` 及信号安装函数 ```sigaction()```。Linux 在支持新版本的这两个函数的同时，仍然支持早期的 ```signal()``` 信号安装函数，支持信号发送函数 ```kill()```。

> 注意，不要有这样的误解：由 ```sigqueue()``` 发送、```sigaction``` 安装的信号就是可靠的。事实上，可靠信号是指后来添加的新信号（信号值位于 SIGRTMIN 及 SIGRTMAX 之间）；不可靠信号是信号值小于 SIGRTMIN 的信号。信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。目前 Linux 中的 signal() 是通过 sigation() 函数实现的，因此，即使通过 signal() 安装的信号，在信号处理函数的结尾也不必再调用一次信号安装函数。同时，由于 signal() 安装的实时信号支持排队，同样不会丢失。

对于目前 linux 的两个信号安装函数：signal() 及 sigaction() 来说，它们都不能把 SIGRTMIN 以前的信号变成可靠信号（都不支持排队，仍有可能丢失，仍然是不可靠信号），而且对 SIGRTMIN 以后的信号都支持排队。这两个函数的最大区别在于：经过 sigaction() 安装的信号都能传递信息给信号处理函数（对所有信号这一点都成立），而经过 signal() 安装的信号却不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。

### 实时信号与非实时信号

早期 Unix 系统只定义了 32 种信号，Ret hat7.2 支持 64 种信号，编号 0-63(SIGRTMIN=31，SIGRTMAX=63)，将来可能进一步增加，这需要得到内核的支持。前 32 种信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的 CTRL C 时，会产生 SIGINT 信号，对该信号的默认反应就是进程终止。后 32 个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。实时信号是 POSIX 标准的一部分，可用于应用进程。

非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。

## 进程对信号的响应

进程可以通过三种方式来响应一个信号：

1. 忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL 及 SIGSTOP；

2. 捕捉信号。定义信号处理函数，当信号发生时，执行相应的处理函数；

3. 执行缺省操作，Linux 对每种信号都规定了默认操作，详细情况请参考[2]以及其它资料。**注意，进程对实时信号的缺省反应是进程终止**。

Linux 究竟采用上述三种方式的哪一个来响应信号，取决于传递给相应 API 函数的参数。

## 信号的发送

发送信号的主要函数有：kill()、raise()、sigqueue()、alarm()、setitimer() 以及 abort()。
Linux信号机制
