## 写在前面

本文是博主对于 Linux 信号机制的学习笔记，素材来源于互联网，在文章末尾给出参考链接。

## 摘要

本文首先介绍了信号是什么及信号的来源，然后从不同角度阐述了信号的种类，接着对信号的生命周期做了详细的介绍。通过对这些内容的学习，可以加深对信号的理解。

## 信号是什么

信号是 Unix、类 Unix 以及其他 POSIX 兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。

下面是常见的 Uinx 信号

![](https://img2020.cnblogs.com/blog/1326851/202008/1326851-20200828125402993-1884859786.png)

早期 Unix 系统只定义了 32 种信号，Red Hat 7.8 支持 64 种信号。```SIGRTMIN``` 之前（含 ```SIGRTMIN```）的信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的 CTRL C 时，会产生 ```SIGINT``` 信号，对该信号的默认反应就是进程终止。

```
[root@centos7 /]# cat /etc/redhat-release
CentOS Linux release 7.8.2003 (Core)
[root@centos7 /]# kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

## 信号的来源

信号事件的发生有两个来源：硬件来源（如键盘或硬件故障）；软件来源，最常用发送信号的系统函数是 ```kill()```、```raise()```、```sigqueue()```、```alarm()```、```setitimer()``` 以及 ```abort()``` 等函数，软件来源还包括一些非法运算等操作。

以上各种信号，按发出信号的原因可以分为以下几类：

1. **与进程终止相关的信号**

当进程退出，或者子进程终止时，发出这类信号。

2. **与进程例外事件相关的信号**

如进程越界，或企图写一个只读的内存区域（如程序正文区），或执行一个特权指令及其他各种硬件错误。

3. **与在系统调用期间遇到不可恢复条件相关的信号**

如执行系统调用 ```exec``` 时，原有资源已经释放，而系统资源又已经耗尽。

4. **与执行系统调用时遇到非预测错误条件相关的信号**

如执行一个并不存在的系统调用。

5. **在用户态下的进程发出的信号**

如我们经常使用 ```kill``` 向其他进程发送信号。

6. **与终端交互相关的信号**

如 CRTL C。

7.**跟踪进程执行的信号**

在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号。内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。如果信号发送给一个正在睡眠的进程，如果进程睡眠在可被中断的优先级上，则唤醒进程；否则仅设置进程表中信号域相应的位，而不唤醒进程。如果发送给一个处于可运行状态的进程，则只置相应的域即可。

## 信号类型

如果从可靠性方面和实时性方面进行分类，以上信号基本可以分为可靠，不可靠信号；实时，非实时信号。

### 可靠性方面

#### 不可靠信号

Linux 信号机制基本上是从 Unix 系统中继承过来的。早期 Unix 系统中的信号机制比较简单和原始，后来在实践中暴露出一些问题，因此，把那些建立在早期机制上的信号叫做"不可靠信号"，信号值小于 ```SIGRTMIN``` 的信号都是不可靠信号。这就是"不可靠信号"的来源。不可靠信号主要存在两个问题：

1. 进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理；因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用 ```signal()```，重新安装该信号。

2. 信号可能丢失。

Linux 支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数（信号安装函数是在可靠机制上的实现）。因此，**Linux 下的不可靠信号问题主要指的是信号可能丢失**。

#### 可靠信号

随着时间的发展，后来出现的各种 Unix 版本力图实现"可靠信号"。由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，**可靠信号的信号值值位于 ```SIGRTMIN``` 和 ```SIGRTMAX``` 之间，这些信号支持排队，不会丢失**。

> 注意，可靠信号是信号值位于 ```SIGRTMIN``` 及 ```SIGRTMAX``` 之间的信号；不可靠信号是信号值小于 SIGRTMIN 的信号。信号的可靠与不可靠只与信号值有关，与其他无关。

### 实时性方面

```SIGRTMIN```之后的信号表示实时信号，等同于前面阐述的可靠信号。

以上是对各种信号的产生源的分类，和信号自身的分类，下面我们接着了解这些信号的生命周期

## 信号的生命周期

### 信号产生

信号事件的发生有两个来源：硬件来源（如键盘或硬件故障）；软件来源，最常用发送信号的系统函数主要有：```kill()```、```raise()```、```sigqueue()```、```alarm()```、```setitimer()``` 以及 ```abort()```。

#### kill()

该系统调用可以用来向任何进程或进程组发送任何信号。参数 ```pid``` 为信号的接收进程 id；```signo``` 为 0 时（即空信号），实际不发送任何信号，但照常进行错误检查，因此，可用于检查目标进程是否存在，以及当前进程是否具有向目标发送信号的权限（root 权限的进程可以向任何进程发送信号，非 root 权限的进程只能向属于同一个 session 或者同一个用户的进程发送信号）。

```
#include <sys/types.h>

#include <signal.h>

int kill(pid_t pid,int signo)
```

#### sigqueue()

```sigqueue()``` 是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持非实时的信号），支持信号带有参数，与函数 ```sigaction()``` 配合使用。第一个参数 ```pid``` 是指定接收信号的进程 I D，第二个参数确定即将发送的信号，第三个参数是一个联合数据结构 ```union sigval```，指定了信号传递的参数，即通常所说的 4 字节值。

```
#include <sys/types.h>

#include <signal.h>

int sigqueue(pid_t pid, int sig, const union sigval val)
```

```
typedef union sigval {
    int  sival_int;
    void *sival_ptr;
}sigval_t;
```

```sigqueue()``` 比 ```kill()``` 传递了更多的附加信息，但 ```sigqueue()``` 只能向一个进程发送信号，而不能发送信号给一个进程组。如果 ```signo=0```，将会执行错误检查，但实际上不发送任何信号，0 值信号可用于检查 pid 的有效性以及当前进程是否有权限向目标进程发送信号。

在调用 ```sigqueue()``` 时，```sigval_t``` 指定的信息会拷贝到对应 ```sig``` 注册的 3 参数信号处理函数的 ```siginfo_t``` 结构中，这样信号处理函数就可以处理这些信息了。由于 ```sigqueue()``` 系统调用支持发送带参数信号，所以比 ```kill()``` 系统调用的功能要灵活和强大得多。

> 注：```sigqueue()``` 发送非实时信号时，第三个参数包含的信息仍然能够传递给信号处理函数；```sigqueue()``` 发送非实时信号时，仍然不支持排队。

#### raise()

向进程本身发送信号，```signo``` 参数为即将发送的信号值。调用成功返回 0；否则，返回 -1。

```
#include <signal.h>

int raise(int signo)
```

#### alarm()

```
#include <unistd.h>
unsigned int alarm(unsigned int seconds)
```

专门为 ```SIGALRM``` 信号而设，在指定的时间 seconds 秒后，将向进程本身发送 ```SIGALRM``` 信号，又称为闹钟信号。进程调用 ```alarm()```后，任何以前的 ```alarm()``` 调用都将无效。如果参数 seconds 为零，那么进程内将不再包含任何闹钟时间。如果调用 ```alarm()```，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回 0。

#### setitimer()

```
#include <sys/time.h>
int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue);
```

```setitimer()``` 比 ```alarm()``` 功能强大，支持 3 种类型的定时器：

1. ```ITIMER_REAL```：设定绝对时间，经过指定的时间后，内核将发送 ```SIGALRM``` 信号给本进程；

2. ```ITIMER_VIRTUAL```：设定程序执行时间，经过指定的时间后，内核将发送 ```SIGVTALRM``` 信号给本进程；

3. ```ITIMER_PROF```：设定进程执行以及内核因本进程而消耗的时间和，经过指定的时间后，内核将发送 ```ITIMER_VIRTUAL``` 信号给本进程；

```setitimer()``` 第一个参数 ```which``` 指定定时器类型（上面三种之一）；第二个参数是结构 ```itimerval``` 的一个实例，结构 ```itimerval``` 形式见附录1。第三个参数可不做处理。

```setitimer()``` 调用成功返回 0，否则返回 -1。

#### bort()

```
#include <stdlib.h>
void abort(void);
```

向进程发送 ```SIGABORT``` 信号，默认情况下进程会异常退出，当然可定义自己的信号处理函数。即使 ```SIGABORT``` 被进程设置为阻塞信号，调用 ```abort()``` 后，```SIGABORT``` 仍然能被进程接收。该函数无返回值。

### 进程对信号的响应

收到信号的进程对各种信号有不同的处理方法。处理方法可以分为三类：

1. 第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。
2. 第二种是忽略某个信号，对该信号不做任何处理，就像未发生过一样。
3. 第三种方法是，对该信号的处理保留系统的默认值，**对大部分的信号的缺省操作是使得进程终止**。此方法为缺省操作。

OS 究竟采用上述三种方式的哪一个来响应信号，取决于传递给相应 API 函数的参数。

在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号，当有信号发送给进程时，对应其位置位。由此可以看出，进程对不同的信号可以同时保留，但对于同一个信号，进程并不知道在处理之前来过多少个。

## 信号的安装（设置信号关联动作）

如果进程要处理某一信号，那么就要在进程中安装该信号。安装信号主要用来确定信号值及进程针对该信号值的动作之间的映射关系，即进程将要处理哪个信号，该信号被传递给进程时，将执行何种操作。

linux 主要有两个函数实现信号的安装：```signal()```、```sigaction()```。其中 ```signal()``` 在可靠信号系统调用的基础上实现, 是库函数，它只有两个参数，不支持信号传递信息，主要是用于非实时信号的安装；而 ```sigaction()``` 是较新的函数（由两个系统调用实现：```sys_signal``` 以及 ```sys_rt_sigaction```），有三个参数，支持信号传递信息，主要用来与 ```sigqueue()``` 系统调用配合使用，当然，```sigaction()``` 同样也支持非实时信号的安装。```sigaction()``` 优于 ```signal()``` 主要体现在支持信号传递信息。

## 信号集及信号集操作函数：

每个进程都有一个用来描述哪些信号递送到进程时将被阻塞的信号集，**该信号集中的所有信号在递送到进程后都将被阻塞**。下面是与信号阻塞相关的几个函数：

```
#include <signal.h>
int  sigprocmask(int  how,  const  sigset_t *set, sigset_t *oldset))；
```

```sigprocmask()``` 函数能够根据参数 how 来实现对信号集的操作，操作主要有三种：

1. ```SIG_BLOCK``` ：在进程当前阻塞信号集中添加 ```set``` 指向信号集中的信号

2. ```SIG_UNBLOCK``` ：如果进程阻塞信号集中包含 ```set``` 指向信号集中的信号，则解除对该信号的阻塞

3. ```SIG_SETMASK``` ：更新进程阻塞信号集为 ```set``` 指向的信号集

```
sigpending(sigset_t *set)
```
获得当前已递送到进程，却被阻塞的所有信号，在 ```set``` 指向的信号集中返回结果。

```
sigsuspend(const sigset_t *mask)
```
用于在接收到某个信号之前, 临时用 ```mask``` 替换进程的信号掩码, 并暂停进程执行，直到收到信号为止。```sigsuspend``` 返回后将恢复调用之前的信号掩码。信号处理函数完成后，进程将继续执行。该系统调用始终返回 -1，并将 errno 设置为 EINTR。

## 信号应用实例

linux 下的信号应用并没有想象的那么恐怖，所要做的最多只有三件事情：

1. 安装信号，推荐使用 ```sigaction()```；

2. 实现三参数信号处理函数，```handler (int signal,struct siginfo *info,void *)```；

3. 发送信号，推荐使用 ```sigqueue()```；

事实上，对有些信号来说，只要安装信号就足够了（信号处理方式采用缺省或忽略），其他可能要做的无非是与信号集相关的几种操作。
