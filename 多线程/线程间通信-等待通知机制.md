## 为什么要有等待通知机制？

线程本身是操作系统（更为准确的说应该是 CPU）中独立的个体，但是实际场景中可能需要它们彼此之间要相互通信和协作。

想像一个场景，A 线程做 int 型变量 i 的累加操作，B 线程等待 i 到了 10000 就打印出 i，怎么处理？

### 轮训

B 线程 while(i == 10000)，这样两个线程之间就有了通信，B 线程不断通过轮训来检测 i == 10000 这个条件。这样可以实现我们的需求，但是也带来了问题：CPU 把资源浪费了 B 线程的轮询操作上，因为 while 操作并不释放 CPU 资源，导致了 CPU 会一直在这个线程中做判断操作。

优点：及时性强
缺点：处理器资源消耗严重

### 轮训 + 睡眠

这种方式就是在 while 循环里面加上一个睡眠时间，其目的就是为了降低 CPU 的消耗，因为在线程睡眠的时候是基本不消耗 CPU 的资源的，但是缺点也很明显，即难以确保及时性。

以上两个问题（处理器资源消耗和通知及时性）看似难以调和，但是 Java 通过内置的等待/通知机制能够很好的解决这个矛盾并实现所需要的功能。

等待/通知的相关方法是任意 Java 对象都具备的，因为这些方法被定义在所有对象的超类 java.lang.Object 上，方法和描述下。

等待/通知机制，是指一个线程 A 调用了对象 Object 的 wait() 方法进入 WAITING 状态，而另一个线程 B 调用了 Object 的 notify() 或者是 notifyAll() 方法，线程 A 收到通知后从对象 Object 上
