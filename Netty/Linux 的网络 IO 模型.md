## 写在前面

本文主要介绍 Unix/Linux 下五种网络 IO 模型，但是。为了更好的理解下面提到的五种网络 IO 的概念，我们有必要先理清下面这几个概念。

### 用户空间与内核空间

一个计算机通常有一定大小的内存空间，如一台计算机有 4GB 的地址空间，但是程序并不能完全使用这些地址空间，因为这些地址空间是被划分为 **用户空间和内核空间** 的。用户应用程序只能使用用户空间的内存，这里所说的使用是指应用程序能够申请的内存空间，并不是真正访问的地址空间。下面看下什么是用户空间和内核空间：

### 用户空间

用户空间是常规进程所在的区域，什么是常规进程，打开任务管理器看到的就是常规进程：

![](assets/markdown-img-paste-20190907213733205.png)

JVM 就是常规进程，驻守于用户空间，用户空间是非特权区域，比如在该区域执行的代码不能直接访问硬件设备。

### 内核空间

内核空间主要是指操作系统运行时所使用的用于程序调度、虚拟内存的使用或者连接硬件资源等的程序逻辑。内核代码有特别的权利，比如它能与设备控制器通讯，控制着整个用于区域进程的运行状态。和 I/O 相关的一点是：所有 I/O 都直接或间接通过内核空间。

那么，为什么要划分用户空间和内核空间呢？这也是为了保证操作系统的稳定性和安全性。用户程序不可以直接访问硬件资源，如果用户程序需要访问硬件资源，必须调用操作系统提供的接口，这个调用接口的过程也就是系统调用。**<font color="#f52814">每一次系统调用都会存在两个内存空间之间的数据交互，通常的网络传输也是一次系统调用，通过网络传输的数据先是从内核空间接收到远程机器的数据，然后再从内核空间复制到用户空间，供用户程序使用。</font>**

下面通过一张图更形象的描述这一过程：

![](assets/markdown-img-paste-20190907213101953.png)

> 小贴士：这种内核空间与用户空间的数据的复制很费时，虽然保住了程序运行的安全性和稳定性，但是牺牲了一部分的效率。但是，目前的操作系统已经针对这一块进行了不错的优化，这里不是我们讨论的重点。

> 小贴士：如何分配用户空间和内核空间的比例也是一个问题，是更多地分配给用户空间供用户程序使用，还是首先保住内核有足够的空间来运行，还是要平衡一下。在当前的 Windows 32 位操作系统中，默认用户空间：内核空间的比例是 1:1，而在 32 位 Linux 系统中的默认比例是 3:1（3GB 用户空间、1GB 内核空间）。

### 同步和异步

同步和异步是一种思想，涉猎到的领域也比较多，在 I/O 领域（同步 IO，异步 IO），请求调用领域（同步请求，异步请求，同步调用，异步调用）。虽然，涉及多种领域，但是思想是一样的。同步和异步，真正的关注点是 **<font color="#f33011">消息通信机制</font>** 。

#### 同步

以 “调用” 为例，所谓同步，就是 **<font color="#f33011">在发出一个 “调用请求” 时，在没有得到结果之前，该 “调用请求” 就不返回，但是一旦调用返回就得到返回值了</font>**。换句话说，就是由 **"调用者" 主动等待 “被调用者” 的结果**。像我们平时写的，方法 A 调用 Math.random() 方法、方法 B 调用 String.substring() 方法都是同步调用，因为调用者主动在等待这些方法的返回。

#### 异步

所谓异步，则正好相反，**<font color="#f33011">当一个异步调用请求发出之后，调用者不会立刻得到这个请求真正的执行完后得出的结果，立即返回的可能只是一个伪结果</font>** 。因此异步调用适用于那些对数据一致性要求不是很高的场景，或者是执行过程很耗时的场景。如果这种场景下，我们希望获取异步调用的结果，"被调用者"可以通过状态、通知来通知调用者，或通过回调函数处理这个调用，对应 Java 中的有 Future/FutureTask、wait/notify 体现了这一思想。

### 阻塞和非阻塞

阻塞和非阻塞其实是针对进程或者是线程的状态来判定的。比如下面的，用户进程从操作系统的内核缓冲区读取数据的时候，如果此时内核缓冲区中的数据还没准备好的话，操作系统可采用的一种方式就是将用户进程阻塞在那儿，那么此时该用户进程的状态就会从运行状态变为阻塞状态，也就是阻塞了。

了解了上面的基础知识之后，接下来我们就正式进入 Linux 的网络 IO 模型。

## Linux 网络 IO 模型

**理解这五种网络 I/O 模型之前，我们还得得先清楚一个网络 IO 事件发生，会涉及到哪些对象，会经历哪些步骤：**

**<font color="#159957">网络 IO 涉及到的对象</font>**

对于一个网络 IO （这里我们 以 read 举例），它会涉及到两个系统对象，一个是调用这个 IO 的进程或者是线程，另一个就是 Linux 系统内核空间和用户空间。

**<font color="#159957">进程执行 I/O 操作的步骤</font>**

进程执行 I/O 操作，归结起来，就是向操作系统发出请求，让它要么把缓冲区里的数据排干净（写），要么用数据把缓冲区填满（读）。进程利用这一机制处理所有数据进出操作，操作系统内部处理这一任务的机制，其复杂程度可能超乎想像，但就概念而言，却非常直白易懂，对于一个网络 IO，这里我们以 read 为例，当一个 read 操作发生时，会经历两个阶段：

1. **<font color="#f52814">内核缓冲区准备数据</font>**

2. **<font color="#f52814">内核缓冲区数据拷贝到用户缓冲区</font>**

几种 IO 模型的区别就体现在这两阶段，下面对这几种 IO 模型进行详细介绍。

### 阻塞 IO

当用户进程开始调用了 recvfrom 这个函数后，就开始了 IO 的 **第一阶段：内核缓冲区准备数据**。对于网络 IO 来说，数据只有在积累到一定的量的时候才会发送，这个时候内核缓冲区就要等待足够的数据到来。而在用户缓冲区这边，**用户进程会一直<font color="#f52814">被操作系统</font>阻塞**，当内核缓冲区数据准备好了，此时就会将内核缓冲区中的数据拷贝到用户缓冲区，然后 **<font color="#f52814">由操作系统唤醒被阻塞的用户进程</font>** 并将结果返回给用户进程，此时用户进程才重新运行起来。所以，**<font color="#f52814">阻塞 IO 的特点就是在 IO 执行的两个阶段都被阻塞了</font>**。

![](assets/markdown-img-paste-20190908133029856.png)

### 非阻塞 IO

从图中可以看出，当用户进程发出 read 操作时，如果内核缓冲区中的数据还没有准备好，**那么它并不会阻塞用户进程，而是立刻返回一个 error**。从用户进程角度讲 ，它发起一个 read 操作后，并没有被阻塞，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作，就这样一直进行下去，到这里第一阶段都是一直在轮训。一旦内核缓冲区中的数据准备好了，并且又再次收到了用户进程的 read 请求，那么它马上就将数据从内核缓冲区拷贝到用户缓冲区，然后返回给用户线程，这是第二阶段。**<font color="#f52814">所以，用户进程在第一阶段其实并没有被操作系统一直阻塞，而是需要不断的主动询问内核缓冲区数据好了没有。只有在第二阶段数据拷贝到时候会被阻塞</font>** 。

![](assets/markdown-img-paste-2019090813300448.png)

### IO 多路复用

IO 多路复用机制

IO 多路复用机制（也称作事件驱动方式（Event Driven IO））具体实现主要分为三种，分别为 select，poll，和 epoll 。下面分别介绍 select，epoll 模型。

#### select 模型或 epoll 模型

![](assets/markdown-img-paste-20190908133507189.png)

注意，上面的阻塞 IO 和非阻塞 IO 用户进程都是只是调用 recvfrom 一个函数，而这里用户进程还会再调用一个 select 函数，当用户进程调用了 select，那么整个进程会被阻塞，而同时，操作系统会 “监视” 所有 select 负责的 socket 所对应的的内核缓冲区的数据，当任何一个 socket 所对应的内核缓冲区中的数据准备好了，就会返回可读条件的通知。此时用户进程再调用 read 操作，将数据从内核缓冲区拷贝到用户缓冲区。

这个图和阻塞 IO 的图其实并没有太大的区别，事实上，还更差一些。因为这里需要使用两个 system call (select 和 recvfrom)，而阻塞 IO 只调用了一个system call (recvfrom)。但是，调用 select 的优势在于它可以同时处理多个 socket。（所以，如果处理的连接数不是很高的话，使用 select 的 web server 不一定比使用 多线程 + 阻塞 IO 的 web server 性能更好，可能延迟还更大。

> 小贴士：select 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。

在 IO 多路复用模型中，实际上，对于每一个 socket，一般都设置成为非阻塞的，但是，如上图所示，整个用户进程实际上是一直被阻塞的。只不过用户进程是被 select 这个函数阻塞的 ，而不是被 socket IO 给阻塞的（或者也可以理解为是操作系统阻塞的）。

这里肯定有人要问那 select 的作用不就是阻塞多个用户进程，然后将这些用户进程与服务器建立的 socket 监视起来，看看哪个 socket 对应的内核缓冲区中的数据准备好了，然后再通知用户进程，让用户进程再发一次 recvfrom 请求来进行数据拷贝。那 epoll 的作用也是这个呀，为啥人家就说 epoll 的效率更高呢？下面，我就来详细的介绍为啥 epoll 效率更高。

从上面我们已经知道了，select 和 epoll 的作用都是监控多个 socket ，但是不一样的是在于他们俩监控方式和通知用户进程的方式不同。举个例子：这里有 100 个 socket 连接被 select 管理着，select 会保存这 100 个连接的 fd_set 数据结构，假如只有 5 个 socket 的内核缓冲区的数据准备好了，此时 select 的方式是将这 5 个 内核缓冲区数据准备好的 socket 连接打上标记，然后将这 100 个连接 fd_set 数据结构全部返回给用户进程，用户进程拿到整个 fd_set 之后，需要遍历整个 fd_set 挑选出那些被标记数据准备好了的连接，然后再去发送 recvfrom 请求。

>小贴士：select 返回给用户进程所有的 fd_set 数据结构，不仅仅浪费网络带宽，而且用户进程拿到之后还要遍历挑选，也浪费性能。另外，一个进程对应的 select 最多只能监控 1024 个 socket。如果想监控更多的 socket 要多个进程，这也是 select 的一个不够优秀的地方。

那么 epoll 和 select 比较有哪些不同的地方呢？

首先，epoll 模型只会将那些内核缓冲区准备好了的数据的连接所对应的的标识告诉给用户进程，不会返回所有的标识。

### 同步 IO

同步，可以理解为在执行完一个函数或调用后，一直等待系统的返回值或消息，这时进程是处于阻塞的，只有接收到返回的值或消息进程才往下执行。说白了，就是如果进程没有完成功能，进程就会一直阻塞，直到完成这个功能。 对于上面select来说，用户进程调用select这个系统调用后，如果当前没有准备好的数据报（不具备条件完成功能）则一直阻塞等待，直到有准备好的数据报，这时内核将成功信息返回给select后才返回（完成功能后返回），进程这时才会解除阻塞。

### 异步 IO

发出异步IO后，IO操作立即返回，用户进程这时就可以去做别的事情了，之后的一切工作都又内核来完成。当kernel有数据可读时，内核自动将数据拷贝到用户空间 (不阻塞用户进程)，拷贝完成后向用户进程发送信号。
linux下的asynchronous IO其实用得很少。先看一下它的流程：




Kafka 之所以受到越来越多的青睐，与它所“扮演”的三大角色是分不开的：

+ **消息系统：** Kafka 和传统的消息系统（也称作消息中间件）都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时，Kafka 还提供了大多数消息系统难以实现的消息顺序性保障及回溯消费的功能。

+ **存储系统：** Kafka 把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效地降低了数据丢失的风险。也正是得益于 Kafka 的消息持久化功能和多副本机制，我们可以把 Kafka 作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题的日志压缩功能即可。

+ **流式处理平台：** Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理类库，比如窗口、连接、变换和聚合等各类操作。

## 基本组成

一个典型的 Kafka 体系架构包括若干 Producer、若干 Broker、若干 Consumer，以及一个 ZooKeeper 集群，如下图所示。其中 **ZooKeeper 是 Kafka 用来负责集群元数据的管理、控制器的选举等操作的。** Producer 将消息发送到 Broker，Broker 负责将收到的消息存储到磁盘中，而 Consumer 负责从 Broker 订阅并消费消息。

![](assets/markdown-img-paste-20190826182221334.png)

整个 Kafka 体系结构中引入了以下3个术语：

1. **Producer：** 生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到 Kafka 中。

2. **Consumer：** 消费者，也就是接收消息的一方。消费者连接到 Kafka 上并接收消息，进而进行相应的业务逻辑处理。

3. **Broker：** 服务代理节点。对于 Kafka 而言，Broker 可以简单地看作一个独立的 Kafka 服务节点或 Kafka 服务实例。大多数情况下也可以将 Broker 看作一台 Kafka 服务器，前提是这台服务器上只部署了一个 Kafka 实例。一个或多个 Broker 组成了一个 Kafka 集群。一般而言，我们更习惯使用首字母小写的 broker 来表示服务代理节点。

在 Kafka 中还有两个特别重要的概念—主题（Topic）与分区（Partition）。Kafka 中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题（发送到 Kafka 集群中的每一条消息都要指定一个主题），而消费者负责订阅主题并进行消费。

主题是一个逻辑上的概念，它还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区称为主题分区（Topic-Partition）。同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。

offset 是消息在分区中的唯一标识，Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，Kafka 保证的是分区有序而不是主题有序。

![](assets/markdown-img-paste-20190826182416753.png)

如上图所示，主题中有4个分区，消息被顺序追加到每个分区日志文件的尾部。Kafka 中的分区可以分布在不同的服务器（broker）上，也就是说，一个主题可以横跨多个 broker，以此来提供比单个 broker 更强大的性能。

每一条消息被发送到 broker 之前，会根据分区规则选择存储到哪个具体的分区。如果分区规则设定得合理，所有的消息都可以均匀地分配到不同的分区中。如果一个主题只对应一个文件，那么这个文件所在的机器I/O将会成为这个主题的性能瓶颈，而分区解决了这个问题。在创建主题的时候可以通过指定的参数来设置分区的个数，当然也可以在主题创建完成之后去修改分区的数量，通过增加分区的数量可以实现水平扩展。

Kafka 为分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。

同一分区的不同副本中保存的是相同的消息（在同一时刻，副本之间并非完全一样），副本之间是“一主多从”的关系，其中 leader 副本负责处理读写请求，follower 副本只负责与 leader 副本的消息同步。副本处于不同的 broker 中，当 leader 副本出现故障时，从 follower 副本中重新选举新的 leader 副本对外提供服务。Kafka 通过多副本机制实现了故障的自动转移，当 Kafka 集群中某个 broker 失效时仍然能保证服务可用。

![](assets/markdown-img-paste-20190826182435650.png)

如上图所示，Kafka 集群中有4个 broker，某个主题中有3个分区，且副本因子（即副本个数）也为3，如此每个分区便有1个 leader 副本和2个 follower 副本。生产者和消费者只与 leader 副本进行交互，而 follower 副本只负责消息的同步，很多时候 follower 副本中的消息相对 leader 副本而言会有一定的滞后。

Kafka 消费端也具备一定的容灾能力。Consumer 使用拉（Pull）模式从服务端拉取消息，并且保存消费的具体位置，当消费者宕机后恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费，这样就不会造成消息丢失。

分区中的所有副本统称为 AR（Assigned Replicas）。所有与 leader 副本保持一定程度同步的副本（包括 leader 副本在内）组成ISR（In-Sync Replicas），ISR 集合是 AR 集合中的一个子集。消息会先发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步，同步期间内 follower 副本相对于 leader 副本而言会有一定程度的滞后。

前面所说的“一定程度的同步”是指可忍受的滞后范围，这个范围可以通过参数进行配置。与 leader 副本同步滞后过多的副本（不包括 leader 副本）组成 OSR（Out-of-Sync Replicas），由此可见，AR=ISR+OSR。在正常情况下，所有的 follower 副本都应该与 leader 副本保持一定程度的同步，即 AR=ISR，OSR 集合为空。

leader 副本负责维护和跟踪 ISR 集合中所有 follower 副本的滞后状态，当 follower 副本落后太多或失效时，leader 副本会把它从 ISR 集合中剔除。如果 OSR 集合中有 follower 副本“追上”了 leader 副本，那么 leader 副本会把它从 OSR 集合转移至 ISR 集合。默认情况下，当 leader 副本发生故障时，只有在 ISR 集合中的副本才有资格被选举为新的 leader，而在 OSR 集合中的副本则没有任何机会（不过这个原则也可以通过修改相应的参数配置来改变）。

ISR 与 HW 和 LEO 也有紧密的关系。HW 是 High Watermark 的缩写，俗称高水位，它标识了一个特定的消息偏移量（offset），消费者只能拉取到这个 offset 之前的消息。

![](assets/markdown-img-paste-2019082618245529.png)

如上图所示，它代表一个日志文件，这个日志文件中有9条消息，第一条消息的 offset（LogStartOffset）为0，最后一条消息的 offset 为8，offset 为9的消息用虚线框表示，代表下一条待写入的消息。日志文件的 HW 为6，表示消费者只能拉取到 offset 在0至5之间的消息，而 offset 为6的消息对消费者而言是不可见的。

LEO 是 Log End Offset 的缩写，它标识当前日志文件中下一条待写入消息的 offset，上图中 offset 为9的位置即为当前日志文件的 LEO，LEO 的大小相当于当前日志分区中最后一条消息的 offset 值加1。分区 ISR 集合中的每个副本都会维护自身的 LEO，而 ISR 集合中最小的 LEO 即为分区的 HW，对消费者而言只能消费 HW 之前的消息。

>注意要点：很多资料中误将上图中的 offset 为5的位置看作 HW，而把 offset 为8的位置看作 LEO，这显然是不对的。

![](assets/markdown-img-paste-20190826182519947.png)

为了让读者更好地理解 ISR 集合，以及 HW 和 LEO 之间的关系，下面通过一个简单的示例来进行相关的说明。如上图所示，假设某个分区的 ISR 集合中有3个副本，即一个 leader 副本和2个 follower 副本，此时分区的 LEO 和 HW 都为3。消息3和消息4从生产者发出之后会被先存入 leader 副本，如下图所示。

![](assets/markdown-img-paste-20190826182533531.png)

在消息写入 leader 副本之后，follower 副本会发送拉取请求来拉取消息3和消息4以进行消息同步。

![](assets/markdown-img-paste-20190826182548482.png)

在同步过程中，不同的 follower 副本的同步效率也不尽相同。如上图所示，在某一时刻 follower1 完全跟上了 leader 副本而 follower2 只同步了消息3，如此 leader 副本的 LEO 为5，follower1 的 LEO 为5，follower2 的 LEO 为4，那么当前分区的 HW 取最小值4，此时消费者可以消费到 offset 为0至3之间的消息。

写入消息（情形4）如下图所示，所有的副本都成功写入了消息3和消息4，整个分区的 HW 和 LEO 都变为5，因此消费者可以消费到 offset 为4的消息了。

![](assets/markdown-img-paste-20190826182603172.png)

由此可见，Kafka 的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的 follower 副本都复制完，这条消息才会被确认为已成功提交，这种复制方式极大地影响了性能。而在异步复制方式下，follower 副本异步地从 leader 副本中复制数据，数据只要被 leader 副本写入就被认为已经成功提交。在这种情况下，如果 follower 副本都还没有复制完而落后于 leader 副本，突然 leader 副本宕机，则会造成数据丢失。Kafka 使用的这种 ISR 的方式则有效地权衡了数据可靠性和性能之间的关系。
<br />  
#####参考:
https://juejin.im/entry/585ba7038d6d810065d3d54a
https://www.cnblogs.com/xrq730/p/5074199.html
https://blog.51cto.com/xingej/1971598
https://www.cnblogs.com/javalyy/p/8882066.html
https://www.jianshu.com/p/6f132d27aeaf?utm_campaign
https://blog.csdn.net/u013374645/article/details/82808301
http://baijiahao.baidu.com/s?id=1604983471279587214&wfr=spider&for=pc
